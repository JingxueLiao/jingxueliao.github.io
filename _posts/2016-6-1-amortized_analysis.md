---
layout: post
title: 摊还分析
---

在数据结构中，可能某个操作特别耗时，但是其他操作的耗时却非常小。这时，用最坏情况下的复杂度来描述整个数据结构的复杂度并不是十分恰当，一个比较好的方法是使用一个操作序列中每个操作的平均耗时来描述该数据结构的性能。通过摊还分析，我们可以计算出数据结构的一个操作序列中每个操作的平均耗时。

注意摊还分析和平均情况分析不一样，摊还分析不涉及概率问题，但它能够保证在最坏情况下每个操作的平均性能。

摊还分析有三种常用技术：

* 聚合分析
* 核算法
* 势能法

下面我们将介绍这三种方法，并以二进制计数器作为例子进行具体分析。

```c++
class Counter {
public:
    void increment() {
        for (int i = 0; i < bits.size(); ++i) {
            bits[i] = !bits[i];
            if (bits[i] == 1)
                break;
        }
    }

private:
    vector<int> bits;
};
```

## 聚合分析

在聚合分析中，我们计算在最坏情况下操作序列的n个操作所耗费的总时间为T(n)，然后得到在最坏情况下每个操作的摊还代价为T(n)/n。

以k位的二进制计数器来作为例子：

```c++
class Counter {
public:
    void increment() {
        for (int i = 0; i < bits.size(); ++i) {
            bits[i] = !bits[i];
            if (bits[i] == 1)
                break;
        }
    }

private:
    vector<int> bits;
};
```

最坏情况下，increment操作的时间复杂度为O(k)。但是对于n个increment组成的操作序列来说，计数器的第i位翻转的次数为n/(2^i)，该序列共进行2n次翻转，所以n个increment组成的操作序列在最坏情况下所耗费的时间为O(n)，每个操作在最坏情况下的摊还代价为O(n)/n = O(1)。

## 核算法

在核算法中，我们对不同的操作给予不同的摊还代价，摊还代价和操作的实际代价可以不一致。当摊还代价大于操作的实际代价时，多出来的部分作为信用被存起来，在后续摊还代价小于实际代价的操作中，可使用存起来的信用来支付差额。

我们选择操作的摊还代价时要满足两个条件：

1. 操作序列总的摊还代价给出了序列总的实际代价的上限，由于我们需要证明最坏情况下每个操作的平均花费很小，所以这个上限应该是一个紧上限。
2. 在序列的每一步中，总摊还代价都应大于等于总实际代价，既每一个操作都不能透支信用（即使会在未来补齐），否则，到该步为止总摊还代价就不再是总实际代价的上限了。

以k位的二进制计数器作为例子：

```c++
class Counter {
public:
    void increment() {
        for (int i = 0; i < bits.size(); ++i) {
            bits[i] = !bits[i];
            if (bits[i] == 1)
                break;
        }
    }

private:
    vector<int> bits;
};
```

对于计数器的任意一位，我们将对其置位操作的摊还代价设置为2，而对其复位操作的摊还代价设置为0，由于复位操作的次数小于等于置位操作的次数，所以信用不会透支。n个increment操作序列的总摊还代价为O(n)，这也是总实际代价的上界。

## 势能法

在势能法中，有一个势函数可以根据数据结构的不同状态计算出相应的势能。我们定义操作序列中第i个操作的摊还代价为实际代价与两个状态的势能差的和。操作序列的总摊还代价等于总实际代价与终止状态和初始状态势能差的和。

势函数应满足对于操作序列中每一步的势能都大于等于初始状态的势能，这样总摊还代价就给出了总实际代价的一个上界，并且总能提前支付。

以k位的二进制计数器作为例子：

```c++
class Counter {
public:
    void increment() {
        for (int i = 0; i < bits.size(); ++i) {
            bits[i] = !bits[i];
            if (bits[i] == 1)
                break;
        }
    }

private:
    vector<int> bits;
};
```

我们将计数器的势能定义为1的个数，初始状态的势能为0，后续操作中势能总大于等于0。假设第i个操作含有t个复位，1个置位，前一状态的势能为b，则该操作的摊还代价为t + 1 + (b - t + 1) - b = 2。所以n个increment操作序列最坏情况的时间复杂度为O(n)。
